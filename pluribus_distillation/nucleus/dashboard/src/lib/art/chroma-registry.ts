
// ChromaRegistry - The central authority for Pluribus Aesthetic Themes
// Generated by Gemini SAGENT-A (Palette Architect)

export interface ChromaDefinition {
  id: string;
  name: string;
  category: 'cyber' | 'organic' | 'void' | 'solar' | 'ethereal' | 'industrial' | 'random';
  description: string;
  colors: {
    primary: string;   // Main accent
    secondary: string; // Supporting accent
    bgGradientStart: string; // For "smoked glass" backgrounds
    bgGradientEnd: string;   // For "smoked glass" backgrounds
    surface: string;   // Panel backgrounds
  };
  glass: {
    blur: number;      // px
    opacity: number;   // 0-1
    noiseOpacity: number; // 0-1
    noiseIntensity: number; // 0-1 (New: Grain amount)
    gradientAngle: number; // deg (New: Direction)
  };
}

// Helper: HSL to String
const hsl = (h: number, s: number, l: number) => `hsl(${h} ${s}% ${l}%)`;

// Helper: Snap Hue to Harmonic Scale (Phase 1 Step 5)
// Snaps to 12-tone equal temperament (30 degree increments)
const snapToHarmonicHue = (hue: number): number => {
  const steps = 12;
  const stepSize = 360 / steps;
  return Math.round(hue / stepSize) * stepSize;
};

// Helper: HSL to Linear RGB component
const hslToLinear = (h: number, s: number, l: number): { r: number, g: number, b: number } => {
  s /= 100;
  l /= 100;
  const k = (n: number) => (n + h / 30) % 12;
  const a = s * Math.min(l, 1 - l);
  const f = (n: number) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
  
  // Convert to Linear RGB
  const toLinear = (c: number) => c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
  return { r: toLinear(f(0)), g: toLinear(f(8)), b: toLinear(f(4)) };
};

// Helper: Calculate Relative Luminance
const getLuminance = (h: number, s: number, l: number): number => {
  const { r, g, b } = hslToLinear(h, s, l);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
};

// Helper: Contrast Ratio (Phase 1 Step 6)
const getContrastRatio = (l1: number, l2: number): number => {
  const bright = Math.max(l1, l2);
  const dark = Math.min(l1, l2);
  return (bright + 0.05) / (dark + 0.05);
};

// Helper: Verify Theme Accessibility
const isAccessible = (primaryHue: number, primarySat: number, primaryLight: number, bgLight: number): boolean => {
  const lumPrimary = getLuminance(primaryHue, primarySat, primaryLight);
  const lumBg = getLuminance(0, 0, bgLight); // Approximation for neutral dark/light bg
  return getContrastRatio(lumPrimary, lumBg) >= 4.5;
};

// Helper: Generate Semantic Names
const PREFIXES = ['Obsidian', 'Cyber', 'Neon', 'Quantum', 'Void', 'Solar', 'Lunar', 'Astral', 'Hyper', 'Deep', 'Mist', 'Iron', 'Crystal', 'Ghost', 'Echo', 'Flux', 'Zero', 'Dark', 'Light', 'Pale', 'Onyx', 'Velvet', 'Carbon', 'Smoke', 'Ash'];
const SUFFIXES = ['Haze', 'Glass', 'Shard', 'Core', 'Wave', 'Pulse', 'Drift', 'Glow', 'Ray', 'Beam', 'Signal', 'Static', 'Noise', 'Dust', 'Vapor', 'Rain', 'Storm', 'Silence', 'Bloom', 'Wisp', 'Veil', 'Mirage', 'Aura', 'Nexus'];

// Helper: Generate a "True Random" theme on the fly
export const generateTrueRandomChroma = (): ChromaDefinition => {
  let hue, primarySat, primaryLight, bgSat, bgLight;
  let attempts = 0;
  
  // Retry until accessible theme found or max attempts reached
  do {
    const seed = Math.random();
    const rawHue = Math.floor(Math.random() * 360);
    hue = snapToHarmonicHue(rawHue);
    primarySat = 70 + Math.random() * 30;
    primaryLight = 50;
    
    // STRICT DESATURATION: 0-4% saturation for "Smoked" look
    bgSat = Math.random() * 4; 
    bgLight = 4 + Math.random() * 6; // Always dark (4-10%)
    attempts++;
  } while (!isAccessible(hue, primarySat, primaryLight, bgLight) && attempts < 10);
  
  const secondaryHue = snapToHarmonicHue((hue + 137.5) % 360); 
  
  return {
    id: `random_${Date.now()}_${Math.floor(Math.random()*1000)}`,
    name: 'Entropy ' + Math.floor(Math.random() * 1000),
    category: 'random',
    description: 'Procedurally generated entropy.',
    colors: {
      primary: hsl(hue, primarySat, primaryLight),
      secondary: hsl(secondaryHue, 60 + Math.random() * 30, 55),
      bgGradientStart: hsl(hue, bgSat, bgLight),
      bgGradientEnd: hsl(snapToHarmonicHue((hue + 60) % 360), bgSat + 2, bgLight - 2),
      surface: hsl(hue, bgSat, bgLight + 4),
    },
    glass: {
      blur: 10 + Math.random() * 15,
      opacity: 0.6 + Math.random() * 0.3,
      noiseOpacity: 0.05 + Math.random() * 0.05,
      noiseIntensity: 0.4 + Math.random() * 0.4,
      gradientAngle: Math.floor(Math.random() * 360),
    }
  };
};

// THE ALGORITHM: Procedurally generate 500+ themes
export const generateChromaRegistry = (): ChromaDefinition[] => {
  const themes: ChromaDefinition[] = [];
  
  // 1. The "Smoked Glass" Collection (Deep, Desaturated, Rich)
  // User Req: "desaturate to light or dark gradients... smoked glassy realistic textures"
  for (let i = 0; i < 200; i++) {
    const rawHue = Math.floor(Math.random() * 360);
    const hue = snapToHarmonicHue(rawHue);
    const name = `${PREFIXES[Math.floor(Math.random() * PREFIXES.length)]} ${SUFFIXES[Math.floor(Math.random() * SUFFIXES.length)]}`;
    
    const primarySat = 60;
    const primaryLight = 60;
    const bgLight = 6 + Math.random() * 2;

    if (!isAccessible(hue, primarySat, primaryLight, bgLight)) {
        // Skip inaccessible themes
        continue;
    }

    themes.push({
      id: `smoked_${i}`,
      name: name,
      category: 'void',
      description: 'A deep, smoked glass aesthetic with faint chromatic aberration.',
      colors: {
        primary: hsl(hue, primarySat, primaryLight), 
        secondary: hsl(snapToHarmonicHue((hue + 180) % 360), 50, 50),
        // STRICT: Saturation 2-4%, Lightness 6-8% -> Truly Neutral Dark Grey
        bgGradientStart: hsl(hue, 2 + Math.random() * 2, bgLight),  
        // Slightly lighter/shifted end for gradient depth
        bgGradientEnd: hsl(snapToHarmonicHue((hue + 40) % 360), 3 + Math.random() * 2, bgLight - 2), 
        surface: hsl(hue, 2, 10),
      },
      glass: {
        blur: 12 + Math.random() * 8,
        opacity: 0.7 + Math.random() * 0.2,
        noiseOpacity: 0.07,
        noiseIntensity: 0.5,
        gradientAngle: 135 + Math.floor(Math.random() * 90), // Generally top-left to bottom-right
      }
    });
  }

  // 2. The "Cyberpunk" Collection (Saturated)
  for (let i = 0; i < 100; i++) {
    const rawHue = Math.floor(Math.random() * 360);
    const hue = snapToHarmonicHue(rawHue);
    const name = `Neon ${SUFFIXES[Math.floor(Math.random() * SUFFIXES.length)]}`;
    
    const primarySat = 100;
    const primaryLight = 50;
    const bgLight = 5;

    if (!isAccessible(hue, primarySat, primaryLight, bgLight)) continue;

    themes.push({
      id: `cyber_${i}`,
      name: name,
      category: 'cyber',
      description: 'High contrast, saturated neon against black.',
      colors: {
        primary: hsl(hue, primarySat, primaryLight),
        secondary: hsl(snapToHarmonicHue((hue + 120) % 360), 90, 60),
        bgGradientStart: hsl(hue, 60, bgLight),
        bgGradientEnd: hsl(snapToHarmonicHue((hue + 180) % 360), 80, 2),
        surface: hsl(hue, 30, 10),
      },
      glass: {
        blur: 4,
        opacity: 0.8,
        noiseOpacity: 0.08,
        noiseIntensity: 0.6,
        gradientAngle: 45,
      }
    });
  }

  // 4. The "Industrial" Collection (Monochrome)
  for (let i = 0; i < 50; i++) {
    const rawHue = Math.floor(Math.random() * 360);
    const hue = snapToHarmonicHue(rawHue);
    const name = `Iron ${SUFFIXES[Math.floor(Math.random() * SUFFIXES.length)]}`;
    
    const primarySat = 10;
    const primaryLight = 60;
    const bgLight = 15;

    if (!isAccessible(hue, primarySat, primaryLight, bgLight)) continue;

    themes.push({
      id: `industrial_${i}`,
      name: name,
      category: 'industrial',
      description: 'Metallic, monochrome, precise.',
      colors: {
        primary: hsl(hue, primarySat, primaryLight),
        secondary: hsl(hue, 5, 40),
        bgGradientStart: hsl(hue, 5, bgLight),
        bgGradientEnd: hsl(hue, 0, 5),
        surface: hsl(hue, 2, 12),
      },
      glass: {
        blur: 20,
        opacity: 0.9,
        noiseOpacity: 0.12, 
        noiseIntensity: 0.8,
        gradientAngle: 180,
      }
    });
  }

  return themes;
};

// Singleton instance
let _registry: ChromaDefinition[] | null = null;

export const getChromaRegistry = () => {
  if (!_registry) {
    _registry = generateChromaRegistry();
  }
  return _registry;
};

export const getRandomChroma = (): ChromaDefinition => {
  const reg = getChromaRegistry();
  // 10% chance of generating a completely new "True Random" theme on the fly
  if (Math.random() < 0.1) {
    return generateTrueRandomChroma();
  }
  return reg[Math.floor(Math.random() * reg.length)];
};
