<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worley Waters Shader Test</title>
    <style>
        body {
            background-color: #050505;
            color: #00ffff;
            font-family: 'JetBrains Mono', monospace;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .container {
            text-align: center;
            border: 1px solid #1a1a1a;
            padding: 40px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
        }
        h1 {
            font-size: 1.2rem;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.8;
        }
        /* Target element for the script */
        .md-header__button.md-logo {
            width: 120px;
            height: 120px;
            margin: 0 auto;
            border: 2px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.05);
        }
        .info {
            margin-top: 20px;
            font-size: 0.8rem;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Worley Waters Prototype</h1>
        <div class="md-header__button md-logo">
            <!-- Canvas will be injected here -->
        </div>
        <div class="info">Restored via Forensic Recovery (6299abf8)</div>
    </div>

    <script>
        // Pluribus Documentation Logo Shader (Restored "Worley Waters")
        // Ported from local asset_shaders/worleywaters.md

        document.addEventListener("DOMContentLoaded", function () {
            const logoLink = document.querySelector(".md-header__button.md-logo");
            if (!logoLink) return;

            const canvas = document.createElement("canvas");
            canvas.width = 120;
            canvas.height = 120;
            canvas.style.width = "120px";
            canvas.style.height = "120px";
            canvas.style.borderRadius = "50%";
            logoLink.innerHTML = "";
            logoLink.appendChild(canvas);

            const gl = canvas.getContext("webgl");
            if (!gl) return;

            const vsSource = `
                attribute vec2 position;
                void main() {
                    gl_Position = vec4(position, 0.0, 1.0);
                }
            `;

            // WORLEY WATERS SHADER
            const fsSource = `
                precision mediump float;
                uniform vec3 iResolution;
                uniform float iTime;

                // WORLEY FUNCTIONS
                float length2(vec2 p){ return dot(p,p); }
                float noise(vec2 p){ return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011); }
                
                float worley(vec2 p) {
                    float d = 1e30;
                    for (int xo = -1; xo <= 1; ++xo) {
                        for (int yo = -1; yo <= 1; ++xo) { // Corrected inner loop increment if needed, but using original "messed up" version first
                            for (int yo_inner = -1; yo_inner <= 1; ++yo_inner) {
                                vec2 tp = floor(p) + vec2(xo, yo_inner);
                                d = min(d, length2(p - tp - noise(tp)));
                            }
                        }
                    }
                    // Re-implementing the core logic correctly based on standard worley
                    // The version from the file had a potential typo in the loop nesting or increments
                    // but I'll stick to the exact code found in docs/javascripts/shader_worley.js first
                }
            `;
            
            // Wait, the file content I read was:
            /*
            float worley(vec2 p) {
                float d = 1e30;
                for (int xo = -1; xo <= 1; ++xo) {
                    for (int yo = -1; yo <= 1; ++yo) {
                        vec2 tp = floor(p) + vec2(xo, yo);
                        d = min(d, length2(p - tp - noise(tp)));
                    }
                }
                return 3.0*exp(-4.0*abs(2.5*d - 1.0));
            }
            */
            // I'll use the EXACT code from the file.

            const fsSourceExact = `
                precision mediump float;
                uniform vec3 iResolution;
                uniform float iTime;

                float length2(vec2 p){ return dot(p,p); }
                float noise(vec2 p){ return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011); }
                
                float worley(vec2 p) {
                    float d = 1e30;
                    for (int xo = -1; xo <= 1; ++xo) {
                        for (int yo = -1; yo <= 1; ++yo) {
                            vec2 tp = floor(p) + vec2(xo, yo);
                            d = min(d, length2(p - tp - noise(tp)));
                        }
                    }
                    return 3.0*exp(-4.0*abs(2.5*d - 1.0));
                }
                
                float fworley(vec2 p) {
                    return sqrt(sqrt(sqrt(
                        worley(p*5.0 + 0.05*iTime) *
                        sqrt(worley(p * 50.0 + 0.12 + -0.1*iTime)) *
                        sqrt(sqrt(worley(p * -10.0 + 0.03*iTime))))));
                }

                void main() {
                    vec2 fragCoord = gl_FragCoord.xy;
                    vec2 uv = fragCoord.xy / iResolution.xy;
                    float t = fworley(uv * iResolution.xy / 1500.0);
                    t *= exp(-length2(abs(0.7*uv - 1.0)));
                    gl_FragColor = vec4(t * vec3(0.1, 1.1*t, pow(t, 0.5-t)), 1.0);
                }
            `;

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error("Shader compile error:", gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }

            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSourceExact);
            if (!vs || !fs) return;

            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            gl.useProgram(program);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1.0, -1.0,
                1.0, -1.0,
                -1.0, 1.0,
                1.0, 1.0,
            ]), gl.STATIC_DRAW);

            const posLoc = gl.getAttribLocation(program, "position");
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const resLoc = gl.getUniformLocation(program, "iResolution");
            const timeLoc = gl.getUniformLocation(program, "iTime");

            const startTime = Date.now();

            function render() {
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.uniform3f(resLoc, canvas.width, canvas.height, 1.0);
                gl.uniform1f(timeLoc, (Date.now() - startTime) * 0.001);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                requestAnimationFrame(render);
            }

            render();
        });
    </script>
</body>
</html>
