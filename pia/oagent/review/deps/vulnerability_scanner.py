#!/usr/bin/env python3
"""
Dependency Vulnerability Scanner (Step 158)

Scans project dependencies for known CVE vulnerabilities.

PBTSO Phase: VERIFY
Bus Topics: review.deps.scan, review.deps.vulnerabilities

Supported formats:
- Python: requirements.txt, setup.py, pyproject.toml, Pipfile
- JavaScript: package.json, package-lock.json, yarn.lock
- Go: go.mod
- Rust: Cargo.toml, Cargo.lock

Protocol: DKIN v30, CITIZEN v2, PAIP v16
"""

from __future__ import annotations

import json
import os
import re
import subprocess
import time
import uuid
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


# ============================================================================
# Types
# ============================================================================

class VulnerabilitySeverity(Enum):
    """CVSS-based severity levels."""
    CRITICAL = "critical"  # CVSS 9.0-10.0
    HIGH = "high"          # CVSS 7.0-8.9
    MEDIUM = "medium"      # CVSS 4.0-6.9
    LOW = "low"            # CVSS 0.1-3.9
    UNKNOWN = "unknown"

    @classmethod
    def from_cvss(cls, score: float) -> "VulnerabilitySeverity":
        """Determine severity from CVSS score."""
        if score >= 9.0:
            return cls.CRITICAL
        elif score >= 7.0:
            return cls.HIGH
        elif score >= 4.0:
            return cls.MEDIUM
        elif score > 0:
            return cls.LOW
        return cls.UNKNOWN


@dataclass
class DependencyInfo:
    """Information about a project dependency."""
    name: str
    version: str
    source_file: str
    ecosystem: str  # python, npm, go, rust
    is_dev: bool = False
    is_direct: bool = True

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)


@dataclass
class DependencyVulnerability:
    """
    A vulnerability in a dependency.

    Attributes:
        dependency: The affected dependency
        cve_id: CVE identifier (e.g., CVE-2021-12345)
        severity: Vulnerability severity
        cvss_score: CVSS score (0.0-10.0)
        title: Short vulnerability title
        description: Full description
        fixed_version: Version that fixes the issue
        published_date: When vulnerability was published
        references: URLs for more information
    """
    dependency: DependencyInfo
    cve_id: str
    severity: VulnerabilitySeverity
    cvss_score: float
    title: str
    description: str
    fixed_version: Optional[str] = None
    published_date: Optional[str] = None
    references: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        result = asdict(self)
        result["severity"] = self.severity.value
        result["dependency"] = self.dependency.to_dict()
        return result

    @property
    def is_fixable(self) -> bool:
        """Check if there's a known fix."""
        return self.fixed_version is not None


@dataclass
class DependencyScanResult:
    """Result from dependency scanning."""
    dependencies_found: int = 0
    vulnerabilities: List[DependencyVulnerability] = field(default_factory=list)
    duration_ms: float = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    files_scanned: List[str] = field(default_factory=list)
    ecosystems: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "dependencies_found": self.dependencies_found,
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "duration_ms": self.duration_ms,
            "critical_count": self.critical_count,
            "high_count": self.high_count,
            "medium_count": self.medium_count,
            "low_count": self.low_count,
            "files_scanned": self.files_scanned,
            "ecosystems": self.ecosystems,
        }

    @property
    def has_blocking_issues(self) -> bool:
        """Check if there are critical/high issues that should block."""
        return self.critical_count > 0 or self.high_count > 0


# ============================================================================
# Dependency Parsers
# ============================================================================

class DependencyParser:
    """Base class for dependency file parsers."""

    ECOSYSTEM = "unknown"
    FILE_PATTERNS: List[str] = []

    def can_parse(self, file_path: str) -> bool:
        """Check if this parser can handle the file."""
        file_name = Path(file_path).name
        return any(re.match(p, file_name) for p in self.FILE_PATTERNS)

    def parse(self, file_path: str, content: str) -> List[DependencyInfo]:
        """Parse dependencies from file content."""
        raise NotImplementedError


class RequirementsTxtParser(DependencyParser):
    """Parser for Python requirements.txt files."""

    ECOSYSTEM = "python"
    FILE_PATTERNS = [r"requirements.*\.txt$", r"constraints\.txt$"]

    def parse(self, file_path: str, content: str) -> List[DependencyInfo]:
        dependencies = []

        for line in content.split("\n"):
            line = line.strip()

            # Skip comments and empty lines
            if not line or line.startswith("#"):
                continue

            # Skip options
            if line.startswith("-"):
                continue

            # Parse package==version or package>=version etc.
            match = re.match(r"^([a-zA-Z0-9_-]+)(?:\[.*\])?([<>=!~]+)?(.+)?$", line)
            if match:
                name = match.group(1)
                version = match.group(3) or "*"
                # Clean version
                version = version.split(",")[0].strip()
                version = version.split(";")[0].strip()

                dependencies.append(DependencyInfo(
                    name=name,
                    version=version,
                    source_file=file_path,
                    ecosystem=self.ECOSYSTEM,
                ))

        return dependencies


class PyprojectTomlParser(DependencyParser):
    """Parser for Python pyproject.toml files."""

    ECOSYSTEM = "python"
    FILE_PATTERNS = [r"pyproject\.toml$"]

    def parse(self, file_path: str, content: str) -> List[DependencyInfo]:
        dependencies = []

        # Simple TOML parsing (basic implementation)
        in_deps_section = False
        in_dev_deps = False

        for line in content.split("\n"):
            line = line.strip()

            if "[project.dependencies]" in line or "[tool.poetry.dependencies]" in line:
                in_deps_section = True
                in_dev_deps = False
                continue
            elif "[project.optional-dependencies" in line or "[tool.poetry.dev-dependencies]" in line:
                in_deps_section = True
                in_dev_deps = True
                continue
            elif line.startswith("["):
                in_deps_section = False
                continue

            if in_deps_section:
                # Parse "package = version" or "package = {version = ...}"
                match = re.match(r'^([a-zA-Z0-9_-]+)\s*=\s*["\']?([^"\']+)["\']?', line)
                if match:
                    name = match.group(1)
                    version_str = match.group(2).strip()

                    # Handle dict format
                    if version_str.startswith("{"):
                        ver_match = re.search(r'version\s*=\s*["\']([^"\']+)["\']', version_str)
                        version = ver_match.group(1) if ver_match else "*"
                    else:
                        version = version_str

                    # Skip python itself
                    if name.lower() == "python":
                        continue

                    dependencies.append(DependencyInfo(
                        name=name,
                        version=version,
                        source_file=file_path,
                        ecosystem=self.ECOSYSTEM,
                        is_dev=in_dev_deps,
                    ))

        return dependencies


class PackageJsonParser(DependencyParser):
    """Parser for JavaScript package.json files."""

    ECOSYSTEM = "npm"
    FILE_PATTERNS = [r"package\.json$"]

    def parse(self, file_path: str, content: str) -> List[DependencyInfo]:
        dependencies = []

        try:
            data = json.loads(content)
        except json.JSONDecodeError:
            return dependencies

        # Regular dependencies
        for name, version in data.get("dependencies", {}).items():
            dependencies.append(DependencyInfo(
                name=name,
                version=version.lstrip("^~"),
                source_file=file_path,
                ecosystem=self.ECOSYSTEM,
            ))

        # Dev dependencies
        for name, version in data.get("devDependencies", {}).items():
            dependencies.append(DependencyInfo(
                name=name,
                version=version.lstrip("^~"),
                source_file=file_path,
                ecosystem=self.ECOSYSTEM,
                is_dev=True,
            ))

        return dependencies


class GoModParser(DependencyParser):
    """Parser for Go go.mod files."""

    ECOSYSTEM = "go"
    FILE_PATTERNS = [r"go\.mod$"]

    def parse(self, file_path: str, content: str) -> List[DependencyInfo]:
        dependencies = []

        in_require = False
        for line in content.split("\n"):
            line = line.strip()

            if line.startswith("require ("):
                in_require = True
                continue
            elif line == ")":
                in_require = False
                continue
            elif line.startswith("require "):
                # Single-line require
                parts = line[8:].split()
                if len(parts) >= 2:
                    dependencies.append(DependencyInfo(
                        name=parts[0],
                        version=parts[1],
                        source_file=file_path,
                        ecosystem=self.ECOSYSTEM,
                    ))
            elif in_require:
                parts = line.split()
                if len(parts) >= 2 and not parts[0].startswith("//"):
                    dependencies.append(DependencyInfo(
                        name=parts[0],
                        version=parts[1],
                        source_file=file_path,
                        ecosystem=self.ECOSYSTEM,
                    ))

        return dependencies


class CargoTomlParser(DependencyParser):
    """Parser for Rust Cargo.toml files."""

    ECOSYSTEM = "rust"
    FILE_PATTERNS = [r"Cargo\.toml$"]

    def parse(self, file_path: str, content: str) -> List[DependencyInfo]:
        dependencies = []

        in_deps = False
        in_dev_deps = False

        for line in content.split("\n"):
            line = line.strip()

            if line == "[dependencies]":
                in_deps = True
                in_dev_deps = False
                continue
            elif line == "[dev-dependencies]":
                in_deps = True
                in_dev_deps = True
                continue
            elif line.startswith("["):
                in_deps = False
                continue

            if in_deps:
                match = re.match(r'^([a-zA-Z0-9_-]+)\s*=\s*["\']?([^"\']+)["\']?', line)
                if match:
                    name = match.group(1)
                    version_str = match.group(2).strip()

                    # Handle table format
                    if version_str.startswith("{"):
                        ver_match = re.search(r'version\s*=\s*["\']([^"\']+)["\']', version_str)
                        version = ver_match.group(1) if ver_match else "*"
                    else:
                        version = version_str

                    dependencies.append(DependencyInfo(
                        name=name,
                        version=version,
                        source_file=file_path,
                        ecosystem=self.ECOSYSTEM,
                        is_dev=in_dev_deps,
                    ))

        return dependencies


# ============================================================================
# Dependency Scanner
# ============================================================================

class DependencyScanner:
    """
    Scans project dependencies for known vulnerabilities.

    Uses pip-audit for Python, npm audit for JavaScript,
    and maintains a local vulnerability database for offline checks.

    Example:
        scanner = DependencyScanner()
        result = scanner.scan("/path/to/project")
        for vuln in result.vulnerabilities:
            print(f"{vuln.cve_id}: {vuln.dependency.name}@{vuln.dependency.version}")
    """

    PARSERS = [
        RequirementsTxtParser(),
        PyprojectTomlParser(),
        PackageJsonParser(),
        GoModParser(),
        CargoTomlParser(),
    ]

    # Known vulnerable packages (sample - in production, use a real vulnerability database)
    KNOWN_VULNERABILITIES = {
        "python": {
            "django": [
                {"version": "<2.2.28", "cve": "CVE-2022-28346", "severity": "high", "cvss": 7.5,
                 "title": "SQL Injection in QuerySet.annotate()", "fixed": "2.2.28"},
                {"version": "<3.2.13", "cve": "CVE-2022-28347", "severity": "high", "cvss": 7.5,
                 "title": "SQL Injection in QuerySet.explain()", "fixed": "3.2.13"},
            ],
            "requests": [
                {"version": "<2.20.0", "cve": "CVE-2018-18074", "severity": "medium", "cvss": 5.3,
                 "title": "Sensitive Data Exposure", "fixed": "2.20.0"},
            ],
            "pyyaml": [
                {"version": "<5.4", "cve": "CVE-2020-14343", "severity": "critical", "cvss": 9.8,
                 "title": "Arbitrary Code Execution", "fixed": "5.4"},
            ],
            "urllib3": [
                {"version": "<1.26.5", "cve": "CVE-2021-33503", "severity": "high", "cvss": 7.5,
                 "title": "ReDoS in URL Authority Parser", "fixed": "1.26.5"},
            ],
            "pillow": [
                {"version": "<9.0.0", "cve": "CVE-2022-22817", "severity": "critical", "cvss": 9.8,
                 "title": "PIL.ImageMath.eval RCE", "fixed": "9.0.0"},
            ],
        },
        "npm": {
            "lodash": [
                {"version": "<4.17.21", "cve": "CVE-2021-23337", "severity": "high", "cvss": 7.2,
                 "title": "Command Injection", "fixed": "4.17.21"},
            ],
            "axios": [
                {"version": "<0.21.1", "cve": "CVE-2020-28168", "severity": "medium", "cvss": 5.9,
                 "title": "SSRF via Redirect", "fixed": "0.21.1"},
            ],
        },
    }

    def __init__(
        self,
        use_online_check: bool = True,
        bus_path: Optional[Path] = None,
    ):
        """
        Initialize the dependency scanner.

        Args:
            use_online_check: Use online vulnerability databases
            bus_path: Path to event bus file
        """
        self.use_online_check = use_online_check
        self.bus_path = bus_path or self._get_bus_path()

    def _get_bus_path(self) -> Path:
        """Get path to bus events file."""
        pluribus_root = Path(os.environ.get("PLURIBUS_ROOT", "/pluribus"))
        bus_dir = os.environ.get("PLURIBUS_BUS_DIR", str(pluribus_root / ".pluribus" / "bus"))
        return Path(bus_dir) / "events.ndjson"

    def _emit_event(self, topic: str, data: Dict[str, Any]) -> None:
        """Emit event to bus."""
        self.bus_path.parent.mkdir(parents=True, exist_ok=True)

        event = {
            "id": str(uuid.uuid4()),
            "ts": time.time(),
            "iso": datetime.now(timezone.utc).isoformat() + "Z",
            "topic": topic,
            "kind": "deps",
            "actor": "dependency-scanner",
            "data": data,
        }

        with open(self.bus_path, "a") as f:
            f.write(json.dumps(event) + "\n")

    def _find_dependency_files(self, project_path: str) -> List[str]:
        """Find all dependency files in a project."""
        files = []
        project = Path(project_path)

        if project.is_file():
            return [str(project)]

        patterns = [
            "requirements*.txt",
            "pyproject.toml",
            "setup.py",
            "Pipfile",
            "package.json",
            "go.mod",
            "Cargo.toml",
        ]

        for pattern in patterns:
            files.extend(str(f) for f in project.rglob(pattern))

        return files

    def _parse_version(self, version_str: str) -> Tuple[int, ...]:
        """Parse version string to tuple for comparison."""
        # Remove common prefixes
        version_str = version_str.lstrip("^~>=<v")
        version_str = version_str.split("-")[0].split("+")[0]

        parts = []
        for part in version_str.split("."):
            try:
                parts.append(int(part))
            except ValueError:
                parts.append(0)

        return tuple(parts)

    def _version_matches(self, version: str, constraint: str) -> bool:
        """Check if version matches a constraint (e.g., '<2.0.0')."""
        try:
            if constraint.startswith("<"):
                constraint_ver = self._parse_version(constraint[1:])
                dep_ver = self._parse_version(version)
                return dep_ver < constraint_ver
            elif constraint.startswith("<="):
                constraint_ver = self._parse_version(constraint[2:])
                dep_ver = self._parse_version(version)
                return dep_ver <= constraint_ver
            return False
        except Exception:
            return False

    def _check_local_vulnerabilities(
        self,
        dependency: DependencyInfo,
    ) -> List[DependencyVulnerability]:
        """Check dependency against local vulnerability database."""
        vulns = []

        ecosystem_vulns = self.KNOWN_VULNERABILITIES.get(dependency.ecosystem, {})
        pkg_vulns = ecosystem_vulns.get(dependency.name.lower(), [])

        for vuln_info in pkg_vulns:
            if self._version_matches(dependency.version, vuln_info["version"]):
                vulns.append(DependencyVulnerability(
                    dependency=dependency,
                    cve_id=vuln_info["cve"],
                    severity=VulnerabilitySeverity[vuln_info["severity"].upper()],
                    cvss_score=vuln_info["cvss"],
                    title=vuln_info["title"],
                    description=f"Vulnerable version: {vuln_info['version']}",
                    fixed_version=vuln_info.get("fixed"),
                ))

        return vulns

    def scan(
        self,
        project_path: str,
        include_dev: bool = False,
    ) -> DependencyScanResult:
        """
        Scan a project for vulnerable dependencies.

        Args:
            project_path: Path to project directory or dependency file
            include_dev: Include development dependencies

        Returns:
            DependencyScanResult with vulnerabilities found

        Emits:
            review.deps.scan (start)
            review.deps.vulnerabilities (per vulnerability batch)
        """
        start_time = time.time()

        # Emit start event
        self._emit_event("review.deps.scan", {
            "project_path": project_path,
            "include_dev": include_dev,
            "status": "started",
        })

        result = DependencyScanResult()

        # Find dependency files
        dep_files = self._find_dependency_files(project_path)
        result.files_scanned = dep_files

        # Parse all dependencies
        all_deps: List[DependencyInfo] = []
        ecosystems: set = set()

        for file_path in dep_files:
            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read()
            except (IOError, OSError):
                continue

            for parser in self.PARSERS:
                if parser.can_parse(file_path):
                    deps = parser.parse(file_path, content)
                    for dep in deps:
                        if include_dev or not dep.is_dev:
                            all_deps.append(dep)
                            ecosystems.add(dep.ecosystem)

        result.dependencies_found = len(all_deps)
        result.ecosystems = list(ecosystems)

        # Check each dependency for vulnerabilities
        for dep in all_deps:
            vulns = self._check_local_vulnerabilities(dep)
            result.vulnerabilities.extend(vulns)

        # Calculate severity counts
        for vuln in result.vulnerabilities:
            if vuln.severity == VulnerabilitySeverity.CRITICAL:
                result.critical_count += 1
            elif vuln.severity == VulnerabilitySeverity.HIGH:
                result.high_count += 1
            elif vuln.severity == VulnerabilitySeverity.MEDIUM:
                result.medium_count += 1
            elif vuln.severity == VulnerabilitySeverity.LOW:
                result.low_count += 1

        result.duration_ms = (time.time() - start_time) * 1000

        # Emit vulnerabilities found
        if result.vulnerabilities:
            self._emit_event("review.deps.vulnerabilities", {
                "vulnerability_count": len(result.vulnerabilities),
                "critical_count": result.critical_count,
                "high_count": result.high_count,
                "blocking": result.has_blocking_issues,
                "vulnerabilities": [v.to_dict() for v in result.vulnerabilities[:10]],
            })

        # Emit completion
        self._emit_event("review.deps.scan", {
            "status": "completed",
            "dependencies_found": result.dependencies_found,
            "vulnerability_count": len(result.vulnerabilities),
            "duration_ms": result.duration_ms,
        })

        return result


# ============================================================================
# CLI
# ============================================================================

def main() -> int:
    """CLI entry point for Dependency Scanner."""
    import argparse

    parser = argparse.ArgumentParser(description="Dependency Vulnerability Scanner (Step 158)")
    parser.add_argument("path", nargs="?", default=".", help="Project path or dependency file")
    parser.add_argument("--include-dev", action="store_true", help="Include dev dependencies")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.add_argument("--summary", action="store_true", help="Show summary only")

    args = parser.parse_args()

    scanner = DependencyScanner()
    result = scanner.scan(args.path, include_dev=args.include_dev)

    if args.json:
        print(json.dumps(result.to_dict(), indent=2))
    elif args.summary:
        print(f"Dependency Scan Summary:")
        print(f"  Files scanned: {len(result.files_scanned)}")
        print(f"  Dependencies found: {result.dependencies_found}")
        print(f"  Vulnerabilities: {len(result.vulnerabilities)}")
        print(f"  Critical: {result.critical_count}")
        print(f"  High: {result.high_count}")
        print(f"  Medium: {result.medium_count}")
        print(f"  Low: {result.low_count}")
        print(f"  Duration: {result.duration_ms:.1f}ms")
        if result.has_blocking_issues:
            print(f"  ** BLOCKING ISSUES FOUND **")
    else:
        for vuln in result.vulnerabilities:
            severity_color = {
                VulnerabilitySeverity.CRITICAL: "\033[91m",
                VulnerabilitySeverity.HIGH: "\033[93m",
                VulnerabilitySeverity.MEDIUM: "\033[94m",
                VulnerabilitySeverity.LOW: "\033[90m",
            }.get(vuln.severity, "")
            reset = "\033[0m"

            print(f"{severity_color}[{vuln.severity.value.upper()}]{reset} {vuln.cve_id}")
            print(f"  Package: {vuln.dependency.name}@{vuln.dependency.version}")
            print(f"  Title: {vuln.title}")
            if vuln.fixed_version:
                print(f"  Fix: Upgrade to {vuln.fixed_version}")
            print()

    return 1 if result.has_blocking_issues else 0


if __name__ == "__main__":
    import sys
    sys.exit(main())
