#!/usr/bin/env python3
"""
PBDOCS Operator - Documentation Auditor & Fixer
===============================================
Protocol: PBDOCS v28
Goal: Ensure comprehensive documentation coverage and link integrity.

Functions:
1. Audit: Scan docs/ for missing index.md files.
2. Fix: Create default index.md for orphans.
3. Fix Links: Convert absolute links to relative, fixing broken refs.
4. Report: Emit coverage metrics to bus.
"""

import os
import sys
import argparse
import json
import re
from pathlib import Path

# Add repo root to path
sys.path.append(str(Path(__file__).parent.parent.parent))

try:
    from nucleus.tools.agent_bus import resolve_bus_paths, emit_event
except ImportError:
    def resolve_bus_paths(d): return None
    def emit_event(*args, **kwargs): print(f"[BUS] {kwargs}")

DOCS_ROOT = "docs"
LINK_PATTERN = re.compile(r'\[([^\]]+)\]\((/[^)]+)\)')

TEMPLATE = """# {title}

Welcome to the {title} documentation section.

## Contents

{contents}

---
*Auto-generated by PBDOCS*
"""

def get_title(dirname):
    return dirname.replace("-", " ").title()

def audit_docs(fix=False):
    missing = []
    fixed = []
    
    for root, dirs, files in os.walk(DOCS_ROOT):
        # Skip assets, overrides, etc.
        if "assets" in root or "overrides" in root or "stylesheets" in root:
            continue
            
        if "index.md" not in files:
            missing.append(root)
            if fix:
                # Generate content list
                links = []
                for f in files:
                    if f.endswith(".md"):
                        links.append(f"- [{f}]({f})")
                for d in dirs:
                    links.append(f"- [{d}/]({d}/index.md)")
                
                content = "\n".join(links) if links else "*No content yet.*"
                title = get_title(os.path.basename(root))
                
                path = os.path.join(root, "index.md")
                with open(path, "w") as f:
                    f.write(TEMPLATE.format(title=title, contents=content))
                fixed.append(path)

    return missing, fixed

def fix_links(dry_run=False):
    fixed_count = 0
    errors = []
    
    for root, _, files in os.walk(DOCS_ROOT):
        for file in files:
            if not file.endswith(".md"): continue
            
            path = os.path.join(root, file)
            with open(path, "r") as f:
                content = f.read()
            
            new_content = content
            modified = False
            
            def replacer(match):
                nonlocal modified
                text = match.group(1)
                link = match.group(2)
                
                # Handle special case for plan
                if link == "/docs-multiagent-plan.md":
                    link = "/planning/multiagent_plan.md"
                
                # Resolve target
                target_path = os.path.join(DOCS_ROOT, link.lstrip("/"))
                
                # Handle directory links
                if not os.path.exists(target_path) and os.path.exists(target_path + "/index.md"):
                     target_path = os.path.join(target_path, "index.md")

                if not os.path.exists(target_path):
                    # Try adding .md
                    if os.path.exists(target_path + ".md"):
                        target_path += ".md"
                    else:
                        # Log error but don't break
                        # errors.append(f"Broken link in {path}: {link}")
                        return match.group(0)

                # Calculate relative path
                rel_link = os.path.relpath(target_path, os.path.dirname(path))
                modified = True
                return f"[{text}]({rel_link})"

            new_content = LINK_PATTERN.sub(replacer, content)
            
            if modified:
                if not dry_run:
                    with open(path, "w") as f:
                        f.write(new_content)
                fixed_count += 1
                
    return fixed_count, errors

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--audit", action="store_true")
    parser.add_argument("--fix", action="store_true")
    parser.add_argument("--fix-links", action="store_true")
    args = parser.parse_args()

    bus_paths = resolve_bus_paths(None)
    actor = os.environ.get("PLURIBUS_ACTOR", "pbdocs-operator")

    if args.audit or args.fix:
        missing, fixed = audit_docs(fix=args.fix)
        print(f"PBDOCS Index Audit Complete.")
        print(f"Missing Indexes: {len(missing)}")
        if args.fix:
            print(f"Fixed Indexes: {len(fixed)}")

    if args.fix_links:
        fixed_links, errors = fix_links(dry_run=False)
        print(f"PBDOCS Link Audit Complete.")
        print(f"Fixed Files with Broken Links: {fixed_links}")

    emit_event(bus_paths, topic="docs.audit.complete", kind="metric", level="info", actor=actor, 
               data={"args": vars(args)},
               trace_id=None, run_id=None, durable=True)

if __name__ == "__main__":
    main()
