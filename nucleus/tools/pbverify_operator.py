#!/usr/bin/env python3
"""PBVERIFY - Pluribus Verification Operator.

DKIN v28 Remediation: Steps 131-140 (Phase 5)

Comprehensive verification operator that:
- Runs full test suite with coverage
- Validates architecture accuracy
- Checks all protocol compliance
- Generates verification report
- Emits remediation.coverage.validated event

Usage:
    python3 nucleus/tools/pbverify_operator.py           # Quick verify
    python3 nucleus/tools/pbverify_operator.py --full    # Full verification
    python3 nucleus/tools/pbverify_operator.py --report  # Generate report
"""
from __future__ import annotations

import json
import os
import subprocess
import sys
import time
import uuid
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

sys.dont_write_bytecode = True


@dataclass
class VerificationResult:
    """Single verification check result."""
    name: str
    passed: bool
    details: str
    duration_ms: float


@dataclass
class VerificationReport:
    """Full verification report."""
    report_id: str
    timestamp: str
    results: list[VerificationResult] = field(default_factory=list)

    @property
    def passed(self) -> bool:
        return all(r.passed for r in self.results)

    @property
    def pass_rate(self) -> float:
        if not self.results:
            return 0.0
        return sum(1 for r in self.results if r.passed) / len(self.results) * 100

    def to_dict(self) -> dict[str, Any]:
        return {
            "report_id": self.report_id,
            "timestamp": self.timestamp,
            "passed": self.passed,
            "pass_rate": round(self.pass_rate, 1),
            "total_checks": len(self.results),
            "passed_checks": sum(1 for r in self.results if r.passed),
            "results": [
                {
                    "name": r.name,
                    "passed": r.passed,
                    "details": r.details,
                    "duration_ms": r.duration_ms,
                }
                for r in self.results
            ],
        }

    def to_markdown(self) -> str:
        lines = [
            "# Verification Report",
            "",
            f"**Report ID:** {self.report_id[:8]}",
            f"**Timestamp:** {self.timestamp}",
            f"**Status:** {'PASSED' if self.passed else 'FAILED'}",
            f"**Pass Rate:** {self.pass_rate:.1f}%",
            "",
            "## Results",
            "",
            "| Check | Status | Details |",
            "|-------|--------|---------|",
        ]

        for r in self.results:
            status = "✓" if r.passed else "✗"
            details = r.details[:40] + "..." if len(r.details) > 40 else r.details
            lines.append(f"| {r.name} | {status} | {details} |")

        lines.extend([
            "",
            "---",
            "*Generated by PBVERIFY Operator - DKIN v28*",
        ])

        return "\n".join(lines)


class PBVerifyOperator:
    """Verification operator for remediation validation."""

    def __init__(self, root: Path | None = None, emit_bus_events: bool = True):
        self.root = root or Path("/pluribus")
        self.nucleus = self.root / "nucleus"
        self.emit_bus_events = emit_bus_events
        self._bus_emit = None

        if emit_bus_events:
            self._init_bus_emitter()

    def _init_bus_emitter(self) -> None:
        try:
            tools_dir = self.nucleus / "tools"
            if str(tools_dir) not in sys.path:
                sys.path.insert(0, str(tools_dir))
            from agent_bus import emit_bus_event as emit_event, resolve_bus_paths
            self._bus_paths = resolve_bus_paths(None)
            self._bus_emit = emit_event
        except Exception:
            self._bus_emit = None

    def _emit_event(self, topic: str, data: dict) -> None:
        if not self._bus_emit:
            return
        try:
            self._bus_emit(
                self._bus_paths,
                topic=topic,
                kind="log",
                level="info",
                actor="pbverify",
                data=data,
                durable=True,
            )
        except Exception:
            pass

    def check_test_suite(self) -> VerificationResult:
        """Run pytest and check results."""
        start = time.time()
        try:
            result = subprocess.run(
                ["python3", "-m", "pytest", "nucleus/tools/tests/", "-q", "--tb=no"],
                cwd=str(self.root),
                capture_output=True,
                text=True,
                timeout=120,
            )

            passed = result.returncode == 0
            # Extract test count from output
            output = result.stdout + result.stderr
            details = output.split('\n')[-2] if output else "No output"

            return VerificationResult(
                name="test_suite",
                passed=passed,
                details=details.strip(),
                duration_ms=(time.time() - start) * 1000,
            )
        except subprocess.TimeoutExpired:
            return VerificationResult(
                name="test_suite",
                passed=False,
                details="Timeout after 120s",
                duration_ms=(time.time() - start) * 1000,
            )
        except Exception as e:
            return VerificationResult(
                name="test_suite",
                passed=False,
                details=str(e),
                duration_ms=(time.time() - start) * 1000,
            )

    def check_secops_coverage(self) -> VerificationResult:
        """Check SecOps module exists and is functional."""
        start = time.time()
        try:
            secops_dir = self.nucleus / "secops"
            required_files = [
                "__init__.py",
                "audit_logger.py",
                "secret_scanner.py",
                "guardrails.py",
                "enforcement.py",
                "permission_checker.py",
                "network_policy.py",
                "credential_rotation.py",
            ]

            missing = [f for f in required_files if not (secops_dir / f).exists()]

            if missing:
                return VerificationResult(
                    name="secops_coverage",
                    passed=False,
                    details=f"Missing: {', '.join(missing)}",
                    duration_ms=(time.time() - start) * 1000,
                )

            # Try import
            sys.path.insert(0, str(self.nucleus))
            from secops import AuditLogger

            return VerificationResult(
                name="secops_coverage",
                passed=True,
                details=f"All {len(required_files)} modules present and importable",
                duration_ms=(time.time() - start) * 1000,
            )
        except Exception as e:
            return VerificationResult(
                name="secops_coverage",
                passed=False,
                details=str(e),
                duration_ms=(time.time() - start) * 1000,
            )

    def check_mcp_servers(self) -> VerificationResult:
        """Verify MCP servers exist."""
        start = time.time()
        mcp_dir = self.nucleus / "mcp"
        servers = list(mcp_dir.glob("*_server.py"))

        return VerificationResult(
            name="mcp_servers",
            passed=len(servers) >= 6,
            details=f"Found {len(servers)} MCP servers",
            duration_ms=(time.time() - start) * 1000,
        )

    def check_membrane_health(self) -> VerificationResult:
        """Check membrane adapter health."""
        start = time.time()
        try:
            sys.path.insert(0, str(self.nucleus / "tools"))
            from membrane_health import MembraneHealthChecker

            checker = MembraneHealthChecker(emit_bus_events=False)
            results = checker.check_all()
            healthy = sum(1 for r in results if r.healthy)

            return VerificationResult(
                name="membrane_health",
                passed=healthy >= len(results) * 0.7,  # 70% healthy
                details=f"{healthy}/{len(results)} adapters healthy",
                duration_ms=(time.time() - start) * 1000,
            )
        except Exception as e:
            return VerificationResult(
                name="membrane_health",
                passed=False,
                details=str(e),
                duration_ms=(time.time() - start) * 1000,
            )

    def check_arch_counts(self) -> VerificationResult:
        """Verify architecture counts are accurate."""
        start = time.time()
        try:
            sys.path.insert(0, str(self.nucleus / "tools"))
            from arch_counter import ArchCounter

            counter = ArchCounter(self.root)
            counts = counter.count_all()

            # Basic sanity checks
            checks = [
                counts.python_tools >= 400,
                counts.spec_files_total >= 100,
                counts.mcp_servers >= 6,
                counts.systemd_services >= 30,
            ]

            passed = all(checks)
            return VerificationResult(
                name="arch_counts",
                passed=passed,
                details=f"Tools:{counts.python_tools} Specs:{counts.spec_files_total} MCP:{counts.mcp_servers}",
                duration_ms=(time.time() - start) * 1000,
            )
        except Exception as e:
            return VerificationResult(
                name="arch_counts",
                passed=False,
                details=str(e),
                duration_ms=(time.time() - start) * 1000,
            )

    def check_bus_health(self) -> VerificationResult:
        """Check bus is functional."""
        start = time.time()
        bus_path = self.root / ".pluribus" / "bus" / "events.ndjson"

        if not bus_path.exists():
            return VerificationResult(
                name="bus_health",
                passed=False,
                details="Bus file not found",
                duration_ms=(time.time() - start) * 1000,
            )

        try:
            size = bus_path.stat().st_size
            line_count = sum(1 for _ in open(bus_path))

            return VerificationResult(
                name="bus_health",
                passed=line_count > 0,
                details=f"{line_count:,} events, {size / 1024 / 1024:.1f}MB",
                duration_ms=(time.time() - start) * 1000,
            )
        except Exception as e:
            return VerificationResult(
                name="bus_health",
                passed=False,
                details=str(e),
                duration_ms=(time.time() - start) * 1000,
            )

    def check_tui_widgets(self) -> VerificationResult:
        """Verify TUI widgets exist."""
        start = time.time()
        widgets_dir = self.nucleus / "tui" / "widgets"

        required = ["status_bar.py", "bus_monitor.py", "lanes_view.py", "daemon_status.py"]
        existing = [f for f in required if (widgets_dir / f).exists()]

        return VerificationResult(
            name="tui_widgets",
            passed=len(existing) == len(required),
            details=f"{len(existing)}/{len(required)} widgets present",
            duration_ms=(time.time() - start) * 1000,
        )

    def run_quick_verification(self) -> VerificationReport:
        """Run quick verification checks."""
        report = VerificationReport(
            report_id=str(uuid.uuid4()),
            timestamp=time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        )

        report.results.append(self.check_secops_coverage())
        report.results.append(self.check_mcp_servers())
        report.results.append(self.check_arch_counts())
        report.results.append(self.check_bus_health())
        report.results.append(self.check_tui_widgets())

        if self.emit_bus_events:
            self._emit_event("remediation.verification.quick", report.to_dict())

        return report

    def run_full_verification(self) -> VerificationReport:
        """Run full verification with tests."""
        report = VerificationReport(
            report_id=str(uuid.uuid4()),
            timestamp=time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        )

        # Quick checks
        report.results.append(self.check_secops_coverage())
        report.results.append(self.check_mcp_servers())
        report.results.append(self.check_membrane_health())
        report.results.append(self.check_arch_counts())
        report.results.append(self.check_bus_health())
        report.results.append(self.check_tui_widgets())

        # Full test suite
        report.results.append(self.check_test_suite())

        if self.emit_bus_events:
            topic = "remediation.coverage.validated" if report.passed else "remediation.coverage.failed"
            self._emit_event(topic, report.to_dict())

        return report


def main():
    import argparse

    parser = argparse.ArgumentParser(description="PBVERIFY - Verification Operator")
    parser.add_argument("--full", action="store_true", help="Run full verification with tests")
    parser.add_argument("--report", action="store_true", help="Generate markdown report")
    parser.add_argument("--json", action="store_true", help="JSON output")
    parser.add_argument("--no-emit", action="store_true", help="Don't emit bus events")

    args = parser.parse_args()

    operator = PBVerifyOperator(emit_bus_events=not args.no_emit)

    if args.full:
        report = operator.run_full_verification()
    else:
        report = operator.run_quick_verification()

    if args.json:
        print(json.dumps(report.to_dict(), indent=2))
    elif args.report:
        print(report.to_markdown())
    else:
        status = "PASSED" if report.passed else "FAILED"
        print(f"PBVERIFY - {status} ({report.pass_rate:.0f}%)")
        print("=" * 50)
        for r in report.results:
            symbol = "✓" if r.passed else "✗"
            print(f"  {symbol} {r.name}: {r.details}")
        print("=" * 50)


if __name__ == "__main__":
    main()
