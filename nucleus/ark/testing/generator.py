#!/usr/bin/env python3
"""
generator.py - Recursive Test Generator

P2-061: Create recursive test generator
P2-076: Create regression test generator

Generates tests recursively based on:
- Code structure (AST analysis)
- Gate requirements (DNA axioms)
- Historical failures (pattern memory)
"""

import ast
import random
import hashlib
import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Callable, Set
from pathlib import Path

logger = logging.getLogger("ARK.Testing.Generator")


@dataclass
class TestCase:
    """A generated test case."""
    id: str
    name: str
    target_function: str
    inputs: Dict[str, Any]
    expected_output: Optional[Any] = None
    oracle: Optional[str] = None  # Assertion expression
    tags: List[str] = field(default_factory=list)
    priority: float = 1.0
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "name": self.name,
            "target_function": self.target_function,
            "inputs": self.inputs,
            "expected_output": self.expected_output,
            "oracle": self.oracle,
            "tags": self.tags,
            "priority": self.priority
        }
    
    def to_python(self) -> str:
        """Generate Python test code."""
        lines = [f"def test_{self.name}():"]
        lines.append(f'    """Auto-generated test for {self.target_function}."""')
        
        # Format inputs
        args = ", ".join(f"{k}={repr(v)}" for k, v in self.inputs.items())
        lines.append(f"    result = {self.target_function}({args})")
        
        if self.oracle:
            lines.append(f"    assert {self.oracle}")
        elif self.expected_output is not None:
            lines.append(f"    assert result == {repr(self.expected_output)}")
        else:
            lines.append("    assert result is not None  # Basic sanity check")
        
        return "\n".join(lines)


@dataclass
class TestSuite:
    """A collection of test cases."""
    name: str
    tests: List[TestCase] = field(default_factory=list)
    coverage: float = 0.0
    passed: int = 0
    failed: int = 0
    
    def add(self, test: TestCase) -> None:
        self.tests.append(test)
    
    def to_python_file(self) -> str:
        """Generate Python test file."""
        lines = [
            '"""',
            f'Auto-generated test suite: {self.name}',
            'Generated by ARK Recursive Test Generator',
            '"""',
            '',
            'import pytest',
            ''
        ]
        
        for test in self.tests:
            lines.append(test.to_python())
            lines.append('')
        
        return "\n".join(lines)


class RecursiveTestGenerator:
    """
    Recursively generates tests from code analysis.
    
    P2-061: Create recursive test generator
    """
    
    def __init__(
        self,
        max_depth: int = 3,
        max_tests_per_function: int = 5,
        use_pattern_memory: bool = True
    ):
        self.max_depth = max_depth
        self.max_tests_per_function = max_tests_per_function
        self.use_pattern_memory = use_pattern_memory
        self._generated: Set[str] = set()
    
    def generate_for_file(self, file_path: str) -> TestSuite:
        """Generate test suite for a Python file."""
        path = Path(file_path)
        suite = TestSuite(name=f"test_{path.stem}")
        
        try:
            code = path.read_text()
            tree = ast.parse(code)
        except Exception as e:
            logger.warning("Failed to parse %s: %s", file_path, e)
            return suite
        
        # Find all functions
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                # Skip private and test functions
                if node.name.startswith('_') or node.name.startswith('test'):
                    continue
                
                tests = self._generate_for_function(node)
                for test in tests:
                    suite.add(test)
        
        return suite
    
    def _generate_for_function(self, func: ast.FunctionDef) -> List[TestCase]:
        """Generate tests for a single function."""
        tests = []
        func_name = func.name
        
        # Analyze arguments
        args = self._analyze_args(func)
        
        # Generate boundary tests
        boundary_tests = self._generate_boundary_tests(func_name, args)
        tests.extend(boundary_tests)
        
        # Generate type tests
        type_tests = self._generate_type_tests(func_name, args)
        tests.extend(type_tests)
        
        # Generate random tests
        random_tests = self._generate_random_tests(func_name, args)
        tests.extend(random_tests)
        
        return tests[:self.max_tests_per_function]
    
    def _analyze_args(self, func: ast.FunctionDef) -> Dict[str, str]:
        """Analyze function arguments with type hints."""
        args = {}
        for arg in func.args.args:
            if arg.arg == 'self':
                continue
            
            # Get type annotation if available
            if arg.annotation:
                type_str = ast.unparse(arg.annotation)
            else:
                type_str = "Any"
            
            args[arg.arg] = type_str
        
        return args
    
    def _generate_boundary_tests(
        self, 
        func_name: str, 
        args: Dict[str, str]
    ) -> List[TestCase]:
        """Generate boundary value tests."""
        tests = []
        
        # Common boundary values by type
        boundaries = {
            "int": [0, 1, -1, 2**31-1, -2**31],
            "float": [0.0, 1.0, -1.0, float('inf'), float('-inf')],
            "str": ["", " ", "a" * 1000],
            "list": [[], [None], list(range(100))],
            "dict": [{}, {"key": "value"}],
            "bool": [True, False],
        }
        
        for i, (arg_name, arg_type) in enumerate(args.items()):
            base_type = arg_type.split('[')[0].lower()
            
            if base_type in boundaries:
                for j, value in enumerate(boundaries[base_type][:2]):
                    test_id = hashlib.md5(
                        f"{func_name}_{arg_name}_{j}".encode()
                    ).hexdigest()[:8]
                    
                    if test_id in self._generated:
                        continue
                    self._generated.add(test_id)
                    
                    # Create test with this boundary value
                    inputs = {arg_name: value}
                    # Fill other args with defaults
                    for other_arg, other_type in args.items():
                        if other_arg != arg_name:
                            inputs[other_arg] = self._default_for_type(other_type)
                    
                    tests.append(TestCase(
                        id=test_id,
                        name=f"{func_name}_boundary_{arg_name}_{j}",
                        target_function=func_name,
                        inputs=inputs,
                        oracle="result is not None or result is None",  # Flexible
                        tags=["boundary", "auto-generated"]
                    ))
        
        return tests
    
    def _generate_type_tests(
        self, 
        func_name: str, 
        args: Dict[str, str]
    ) -> List[TestCase]:
        """Generate type-based tests."""
        tests = []
        
        # Create a test with all proper types
        proper_inputs = {
            arg: self._default_for_type(arg_type)
            for arg, arg_type in args.items()
        }
        
        test_id = hashlib.md5(f"{func_name}_proper".encode()).hexdigest()[:8]
        if test_id not in self._generated:
            self._generated.add(test_id)
            tests.append(TestCase(
                id=test_id,
                name=f"{func_name}_proper_types",
                target_function=func_name,
                inputs=proper_inputs,
                tags=["type-check", "auto-generated"]
            ))
        
        return tests
    
    def _generate_random_tests(
        self, 
        func_name: str, 
        args: Dict[str, str]
    ) -> List[TestCase]:
        """Generate random value tests."""
        tests = []
        
        for i in range(2):  # Generate 2 random tests
            inputs = {
                arg: self._random_for_type(arg_type)
                for arg, arg_type in args.items()
            }
            
            test_id = hashlib.md5(
                f"{func_name}_random_{i}_{random.random()}".encode()
            ).hexdigest()[:8]
            
            if test_id not in self._generated:
                self._generated.add(test_id)
                tests.append(TestCase(
                    id=test_id,
                    name=f"{func_name}_random_{i}",
                    target_function=func_name,
                    inputs=inputs,
                    tags=["random", "auto-generated"]
                ))
        
        return tests
    
    def _default_for_type(self, type_str: str) -> Any:
        """Get default value for type."""
        defaults = {
            "int": 0,
            "float": 0.0,
            "str": "test",
            "bool": True,
            "list": [],
            "dict": {},
            "None": None,
            "Any": "test"
        }
        base_type = type_str.split('[')[0].strip()
        return defaults.get(base_type, None)
    
    def _random_for_type(self, type_str: str) -> Any:
        """Get random value for type."""
        base_type = type_str.split('[')[0].strip().lower()
        
        if base_type == "int":
            return random.randint(-100, 100)
        elif base_type == "float":
            return random.uniform(-100, 100)
        elif base_type == "str":
            length = random.randint(1, 20)
            return ''.join(random.choices('abcdefghij', k=length))
        elif base_type == "bool":
            return random.choice([True, False])
        elif base_type == "list":
            return [random.randint(0, 10) for _ in range(random.randint(0, 5))]
        elif base_type == "dict":
            return {f"key{i}": i for i in range(random.randint(0, 3))}
        else:
            return None
    
    def generate_regression_tests(
        self,
        failures: List[Dict[str, Any]]
    ) -> TestSuite:
        """
        Generate regression tests from failures.
        
        P2-076: Create regression test generator
        """
        suite = TestSuite(name="regression_tests")
        
        for failure in failures:
            func_name = failure.get("function", "unknown")
            inputs = failure.get("inputs", {})
            error = failure.get("error", "")
            
            test_id = hashlib.md5(
                f"regression_{func_name}_{str(inputs)}".encode()
            ).hexdigest()[:8]
            
            test = TestCase(
                id=test_id,
                name=f"regression_{func_name}_{test_id}",
                target_function=func_name,
                inputs=inputs,
                oracle=f"# Previously failed with: {error[:50]}",
                tags=["regression", "failure-reproduction"],
                priority=2.0  # Higher priority
            )
            suite.add(test)
        
        return suite
